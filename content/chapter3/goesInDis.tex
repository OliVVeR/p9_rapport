\section{Inaccuracies and Assumptions}\label{sec:in_and_ass}
During our development of \gls{cora} and \gls{smc} model, we have made some decisions that may not always be in favour of realistically representing the state of the outside world. This section will go over each of the choices made to evaluate on the potential effect it can have when all of the factor are taking into consideration.

%More than one window for a payload \cref{ssec:multi_window}
In \myref{sec:read_input} we describe how a window can be assigned to a payload, but multiple windows for a payload was never explored, even though our models could support it. But given our payload descriptions semantic does not allow for multiple windows this is considered a minor inaccuracy.

Introducing the variable idle\_cost to our \myref{sec:read_input} could reduce the computation time required for producing a schedule in \gls{cora}. It is meant to reduce the number of payloads, by removing operational payloads that run frequently and adds no profit to the schedule. And simulate their energy requirements via the idle\_cost variable. But this could give misleading results since idle\_cost represent the average energy cost for the operational payloads and continuously drain on the battery unlike payloads that only drains on the battery for short periods. But by setting idle\_cost to zero and specifying all payload running on the nanosatellite this variable will not cause any misrepresentation to the produced schedule.

In \myref{sec:cora} we mention the need for priorities to indicate the profit for each of the payloads, the prioritisation can be set to a value between zero and five, five being the most important payload to execute in terms of profit. This dose not immediately impose any inaccuracies unless the user defines more than six payloads each with their distinct priority.

We used an Ideal battery model given \gls{cora} restrictions, This will according to the observations made during \myref{sec:kibam} overestimate the battery compared to a real battery, which produces schedules that uses more energy than they have. The impact of this is mitigated with our \gls{smc} model having a more pessimistic battery model.

The Processor template in the \gls{cora} model, see \myref{sec:cora}, models the nanosatellite's processor. Here we mentions two factor that can have an effect on the optimal schedule. A payload is always executed based on its worst execution time, and deadlines force the model to wait a period after the payload has been executed. Payloads running worst case has the benefit of taken more energy from a battery model that already overestimate the actual value. But schedules produced this way may sometimes be less profitable, compared to schedules generate based on best case running time for payloads, the drawback with this approach is the reduced energy taken from the battery and potentially skipping payloads due to some payloads taking a bit more time then the best case and thus causing more energy to be drawn from the battery. This can cause a chain reaction of payloads being skipped based on the individual payloads dependencies and windows when the schedule is verified via \gls{smc}. Additionally the way dependencies are modelled, would not enable all forms of payload dependencies, which can lead to less optimal schedules if user is not able model their payload dependencies with our dependency rules.
Deadlines is only a problem if changes are made to the \gls{cora} model to execute payload in best execution time instead of worst case execution time, because it is possible to set deadline for each payload to their worst case execution time, negating any effect deadlines may have on the schedule. Deadlines are intended to allow payloads in \gls{smc} model to be executed, even when their starting time have passed, as long as it is does not exceed the deadline defined by the payload being executed.

In \gls{cora} \cref{ssec:cora_ins} describing insolation we made two inaccuracies for the sake of performance.  Dividing the number of updates made to the battery during an orbit, and insolation period lasting precisely half the orbit length. Determining the severity of reducing the number of updates to the battery during an orbit, showed a big decrease in time taking to produce the schedule with the effect of an added inaccuracy which we concluded to be neglectable. Another side effect that may occurred  if the orbit length divided by the number of updates produces a fractional number, resulting in \gls{cora} model not updating the correct amount of times for an orbit, due to \gls{cora} rounding down decimals to the nearest natural number.

The PayloadWindow in \myref{sec:cora} mentions that our orbit are modelled circular, where a more representative picture of and orbit would be more oval in shape. This inaccuracy mean that schedules should be rather short in length, because longer schedules further increase the inaccuracy as time goes by.

Modifications to the \gls{smc} model were also been done, as described in \myref{sec:smc_model}, \gls{kibam} is one of the factors that impact the \gls{smc} model, unlike in \gls{cora} where the battery model overestimated the battery, \gls{kibam} underestimate resulting in few schedules being discarded even though the may be viable.

%Starting value from future work \cref{ssec:start_val}
Our \gls{cora} model does not support knowledge from previous schedules, so the variable \uppVar{runs[]} that keep track of which payloads has been executed will always initialize zero, making it impossible to generate a schedule based on the \uppVar{runs[]} from the previous schedule.

To conclude on this we can divide the behaviours into two categories, "will", and "may" effect schedule. will includes battery models, worst payload running time, general insolation because these factors will always have an effect on the produced schedule. May on the other hand can be tweaked by the user to have no effect on the produced schedule, these are number of updates per orbit on the battery, five prioritisation limit on payloads, deadline on payloads.
\jfx{Too short? What can we then say?}



 






