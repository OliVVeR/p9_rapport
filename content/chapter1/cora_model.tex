\section{Cora Model} \label{sec:cora}
Based on the information gained during the previous sections we have constructed a model in \gls{cora} capable of generating schedules for the nanosatellite. The \gls{cora} model takes a set of payloads with some requirements which works as constrains, and other descriptive values, as described in \cref{sec:read_input}, in order to generate a schedule that upholds the specifications. Such descriptions are fed to the model via our own translator.\\
The \gls{cora} model is composed of four templates; Processor, Scheduler, Insolation, and PayloadWindow. These models different aspects of the nanosatellite and its environment, and are all described separately below.\\
The templates Processor and Scheduler, are roughly based on those presented in the GomX-3 article\cite{gomx3}, but have been modified to fit our context as well as handle the added parameters.\\
The model is made to optimise in regards to profit, see \cref{sec:read_input}, this is done as the battery level is rarely a concern\cite{gom_space_conversation}. We therefore chose the approach where we found the schedule that would yield the highest profit, according to input specification, while having the battery level in mind. As \gls{kibam} is pessimistic in the sense that it underestimates the state of charge it would be a good choice to implement. However due to the complexity of \gls{kibam} and the need for non-linear rates \gls{cora} in not the right tool for this, therefore we have chosen to model the ideal battery model.\\
The model is made to always use the worst case execution time, meaning the time it takes to complete a payload may vary. Since no one has control over this we chose to assume the worst. This means more energy will be consumed during simulation that what would more likely be the actual consumption.\\
When setting the cost rate, see \cref{sec:upp_cora}, the user defined profit is used. However, when the user defines the profit, a large number represents that the payload is profitable to execute. In \gls{cora} when running a query where we extract the best trace, it is defined as the one with the lowest cost. Because of this we have to calculate the cost as a function based on the defined profit, how this is done can be seen in \cref{lst:calcCost}.\\
The basics of the function \uppVar{calcCost()} is, to calculate the cost rate by subtracting the defined profit from $5$. However, if the nanosatellite is within a window where another payload can only be performed the cost rate will be multiplied by two making it more expensive run perform.\\


\begin{figure}[h]
	\begin{lstlisting}[language=my_c, caption={Function calcCost(), used for calculating the cost rate}, label=lst:calcCost]
void calcCost(){
	.
	.
	.
	else {runCost = 5 - Profit[active]; return;}
	for (i=0;i < Windows;i++){ 
		if(pen && RunInWindow[i][active] == 0){
			runCost = (5 - Profit[active]) *2;
			return;
		} 
	}
}	
	\end{lstlisting}
\end{figure}


The only query run in the \gls{cora} model is the one seen in query \ref{eq:cora_q}. In this query \uppVar{t\_time} it the accumulated time, and \uppVar{ScheduleLength} is the desired length of the schedule. This query is run with the trace setting \textit{Best}, meaning it will find the schedule that results in the lowest \textit{cost}, i.e. the highest profit. 
Therefore the result of this query is the schedule with the highest profit, and this is what the \gls{smc} model will build upon.

\begin{equation} \label{eq:cora_q}
E<> t\_time == ScheduleLength
\end{equation}

\subsection*{Processor}\label{ssec:cora_pro}
First we will describe the Processor template as it is the base for the entire model. This models the nanosatellite in the sense that it is the one symbolising that the processor is active or idling, as well as consuming power while doing so, as seen in \cref{fig:cora_pro}. \\
The processor template synchronise with the scheduler every time it is ready to execute a payload, the scheduler will then send back a synchronisation if the Processor is allowed to do so. If it is not allowed to execute the payload it will start idling until a change in its environment occurs, indicated by the synchronisation \uppSync{win?}. 
If the Scheduler indicates it is possible to execute the payload, it may be the case that the environment does not allow it, e.g. if the payload is dependant on a window which the nanosatellite is not currently in, the processor will try to select another payload to run. If the Scheduler approves and all dependencies are fulfilled, the Processor will transition to \uppLoc{Running} where it will remain for the worst case execution time for the selected payload before it transitions to \uppLoc{Wait} where it will remain for the duration of the payloads deadline.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	%Locations
	\node [init] (l0) {$\cup$};
	\node [location] (l1) [right of=l0, xshift=30mm] {$\cup$};
	\node [location] (l2) [right of=l1, xshift=40mm, label={
		[align=left]right:
		\textcolor{name}{ready}
	}] {$\cup$};
	\node [location] (l3) [below of=l1, yshift=-30mm, label={
		[align=right]left:
		\textcolor{name}{Wait}\\
		\textcolor{invariant}{x <= TaskTimes[active][2]}
	}] {};
	\node [location] (l4) [below of=l2, yshift=-30mm, label={
		[align=left]right:
		\textcolor{name}{running}\\
		\textcolor{invariant}{x <= TaskTimes[active][1]}\\
		\textcolor{invariant}{\&\& cost' == runCost}
	}] {};
	\node [location] (l5) [above of=l2, yshift=35mm] {C};
	\node [location] (l6) [above of=l1, yshift=35mm, label={
		[align=left]above:
		\textcolor{name}{Idle}\\
		\textcolor{invariant}{cost' == 5}
	}] {};
	\path[->,black, thick] (l0) edge node [midway, below ][align=center]{\textcolor{update}{mayRun()}} (l1);
	\path[->,black, thick] (l1) edge node [midway, above][align=left]{
		\textcolor{select}{a: int[0,N-1]}\\
		\textcolor{guard}{runnableCount() > 0}\\
		\textcolor{guard}{\&\& runnable[a] == 1}\\
		\textcolor{sync}{ready!}\\
		\textcolor{update}{mayRun(), active = a}} (l2);
	\path[->,black, thick] (l2) edge node [midway, right][align=left]{
		\textcolor{guard}{runnable[active] == 1}\\
		\textcolor{guard}{\&\& !checkBattery()}\\		
		\textcolor{sync}{run?}\\
		\textcolor{update}{updateBattery(), calcCost()}} (l4);
	\path[->,black, thick] (l2) edge[bend right=35] node [midway, left][align=center]{
		\textcolor{sync}{run?}}(l6);
	\path[->,black, thick] (l4) edge node [midway, below][align=center]{
		\textcolor{guard}{x >= taskTimes[active][1]}} (l3);
	\path[->,black, thick] (l3) edge node [midway, left][align=right]{
		\textcolor{guard}{x >= taskTimes[active][2]}\\
		\textcolor{update}{reset(), dequeue(),}\\
		\textcolor{update}{x = 0, mayRun()}} (l1);
	\path[->,black, thick] (l1) edge node [midway, left][align=left]{
		\textcolor{guard}{runnableCount() == 0}} (l6);
	\path[->,black, thick] (l6) edge node [midway, above][align=left]{
		\textcolor{sync}{win?}} (l5);
	\path[->,black, thick] (l5) edge node [midway, right][align=left]{
		\textcolor{select}{a: int[0,N-1]}\\
		\textcolor{sync}{ready!}\\
		\textcolor{update}{mayRun(), active = a}} (l2);
	\path[->,black, thick] (l2) edge[bend left=45] node [midway, below][align=center]{
		\textcolor{guard}{runnable[active] == 0}\\
		\textcolor{guard}{\&\& !checkBattery()}\\
		\textcolor{sync}{run?}} (l1);
	\end{tikzpicture}
	\caption{Processor template}
	\label{fig:cora_pro}
\end{figure}



\subsubsection*{Scheduler}\label{ssec:cora_sch}
Next we will describe the Scheduler. The scheduler always checks if there are enough remaining energy. When receiving the synchronisation \uppSync{ready?} it will answer back with \uppSync{run!}. And if there are at any time is no more energy this template will result in a deadlock, discarding the current trace and attempting another one. If all traces results in a deadlock it was not possible to generate a schedule with the specified parameters.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	%Locations
	\node [init] (l0) [label={[align=left]left:
		\textcolor{invariant}{checkBattery()}
	}] {};
	\node [location] (l1) [right of=l0, xshift=40mm, label={
		[align=left]right:
		\textcolor{invariant}{checkBattery()}
	}] {$\cup$};
	\path[->,black, thick] (l0) edge[bend left=30] node [midway, above][align=center]{
		\textcolor{sync}{ready?}} (l1);
	\path[->,black, thick] (l1) edge[bend left=30] node [midway, below][align=center]{
		\textcolor{sync}{run!}} (l0);
	\end{tikzpicture}
	\caption{Scheduler template}
	\label{fig:cora_schedule}
\end{figure}


\subsection*{Insolation} \label{ssec:cora_ins}
The insolation template can be seen in \cref{fig:cora_inso}. The model consist of two locations \uppLoc{inSun} and \uppLoc{inEclipse}. The nanosatellite can only recharge when it has a clear line of sight to the sun, which is indicated by the location \uppLoc{inSun}. The recharging is done on the looping edge on \uppLoc{inSun} with the function \uppUpdate{increaseBattery()}. This is done four times per orbit, rather than for each time unit, in order to minimize the state space. When half of the \uppVar{OrbitTime} have passed, modelling the time it takes the nanosatellite to complete one half orbit, the model is forced to transition to \uppLoc{inEclipse}. Note that it is assumed that the nanosatellite always spends exactly half its time in insolation.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	%Locations
	\node [init] (l0) [label={
		[align=left]above:
		\textcolor{name}{inSun}
	}, label={
	[align=left]left:
	\textcolor{invariant}{splitTime <= OrbitTime / 8}\\
	\textcolor{invariant}{\&\& ins <= OrbitTime / 2}
}] {};
\node [location] (l1) [right of=l0, xshift=40mm, label={
	[align=left]above:
	\textcolor{name}{inEclipse}
}, label={
[align=left]right:
\textcolor{invariant}{splitTime <= OrbitTime / 8}\\
\textcolor{invariant}{\&\& ins <= OrbitTime / 2}
}] {};
%Edges
\path[->,black, thick] (l0) edge[bend left=30] node [midway, above][align=left]{
	\textcolor{guard}{ins >= OrbitTime / 2}\\
	\textcolor{guard}{\&\& chargeCount == 4}} (l1);
\path[->,black, thick] (l1) edge[bend left=30] node [midway, below][align=left]{
	\textcolor{guard}{ins >= OrbitTime}\\
	\textcolor{guard}{\&\& chargeCount == 8}\\
	\textcolor{update}{ins := 0,}\\
	\textcolor{update}{splitTime = 0}\\
	\textcolor{update}{chargeCount = 0}} (l0);
\path[->,black, thick] (l0) edge [loop below] node [midway, below left][align=left]{
	\textcolor{guard}{splitTime >= OrbitTime/8}\\
	\textcolor{update}{increaseBattery()}} (l0);
\path[->,black, thick] (l1) edge [loop below] node [midway, below right][align=left]{
	\textcolor{guard}{splitTime >= OrbitTime/8}\\
	\textcolor{update}{subIdle()}} (l1);
\end{tikzpicture}
\caption{Insolation template}
\label{fig:cora_inso}
\end{figure}

The way this is modelled have a few assumptions, and inaccuracies as previously mentioned we only recharge four times during insolation. This may result in a suboptimal schedule as executing a payload may cause the state of charge to fall below the threshold, and therefore not be executed, where the state of charge should be higher potentially resulting in it being possible to execute the payload. We however believe this to be an edge-case that will rarely occur.
In \cref{fig:granularity} we see a graph over the state of charge(left) while doing nothing but charging. On the right, is a close-up of the same graph. The blue line shows what the state of charge should be and the orange what it is with our implementation. Clearly our implementation is not entirely accurate, but neither is the ideal battery model, and because of this we believe a small margin of error is acceptable given the much reduced state space.

\begin{figure}[h]%
	\centering
	\subfloat{{\includegraphics[width=7cm]{graphics/granularity.png} }}%
	\qquad
	\subfloat{{\includegraphics[width=7cm]{graphics/granularity_zoom.png} }}%
	\caption{Graphs illustrating state of charge, with different granularity.}%
	\label{fig:granularity}%
\end{figure}

To find the effect of this state-space reduction we generated $2 * 10$ schedules of $12hours$ each, ten with our simplification and ten where recharge was added for every unit of time elapsed. The differences in time spend to generate these were quite significant and can be seen in \cref{tab:runTimes}. There it is seen that the worst case found when charging every time unit was $138.76\%$ more than when using our simplification.



\begin{table}[H]
	\centering
	\begin{tabular}{lllll}
		& Granularity 1(s)           & Granularity 11(s)          & Time Increase(\%)           &  \\ \cline{2-4}
		\multicolumn{1}{l|}{Best}    & \multicolumn{1}{l|}{39.63} & \multicolumn{1}{l|}{21.13} & \multicolumn{1}{l|}{85.53}  &  \\
		\multicolumn{1}{l|}{Worst}   & \multicolumn{1}{l|}{64.68} & \multicolumn{1}{l|}{27.09} & \multicolumn{1}{l|}{138.76} &  \\
		\multicolumn{1}{l|}{Average} & \multicolumn{1}{l|}{48.13} & \multicolumn{1}{l|}{24.89} & \multicolumn{1}{l|}{93.37}  &  \\ \cline{2-4}
	\end{tabular}
		\caption{Run times when generating a 12 hour schedule, using different granularity for insolation}
		\label{tab:runTimes}
\end{table}
		
Additionally it is assumed that the nanosatellite are always starting in insolation, resulting in our model only being able to generate an accurate schedule for the nanosatellite, when it matches our starting point.


\subsection*{PayloadWindow}\label{ssec:cora_tw}
The last template is the PayloadWindow, this template have one instance for each window defined. PayloadWindow is used to model part of the nanosatellites environment in the sense that it updates whenever the nanosatellite enters and exits a window during its orbit in which some tasks can be performed. Windows is an important restriction when generating a schedule as some payloads may be pointless to execute in other time periods and would therefore be a waste of energy and time. When a change to a window occurs it will synchronise on the channel \uppChan{win}, with the processor if it is in \uppLoc{Idle} indicating it may now be possible to execute some payload. Otherwise it will just transition to the next location updating some global variables indicating if the nanosatellite is within the window or not. 
A figure of this template can be seen in \cref{fig:cora_window}.\\
It is assumed that the orbit is constant for the duration of the schedule. This means that the defined windows are constant whereas they would more realistically change during operation, e.g. at start time window(1) will occur at time 10 and end at time 30, then after 5 orbits the window may occur at time 11 to 31.

