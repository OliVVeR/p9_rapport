\section{Cora Model} \label{sec:cora}
Based on the previous information gained during the previous sections we have constructed a model in \gls{cora} capable of generating schedule for the nanosatellite. The \gls{cora} model takes a set of payloads with some rules and constrains, as described in \cref{sec:read_input}, in order to generate a schedule that upholds the specifications. These are fed to the model via our own translator.\\
The \gls{cora} model is composed of four templates; Processor, Scheduler, Insolation, and TaskWindow. These models different aspects of the nanosatellite and its environment, and are all described separately below.\\
The templates Processor and Scheduler, are roughly based on those presented in the GomX-3 article\cite{gomx3}, but have been modified to fit our context as well as handle the added parameters.\\
The model is made to optimise in regards to profit, see \cref{sec:read_input}, this is done as a result of Lars Alminde from GomSpace, during a meeting expressing that the battery level is rarely a concern. We therefore chose the approach where we found the schedule that would yield the highest profit, according to input specification, while having the battery level in mind. As a result of this the model implements a linear battery model\\
The model is made to always use the worst case execution time, meaning the time it takes to complete a payload may vary. Since no one has control over this we chose to assume the worst. This means more energy will be consumed during simulation that what would more likely be the actual consumption.\\
The only query run in the \gls{cora} model is the one seen in query \ref{eq:cora_q}. In this query \uppVar{t\_time} it the accumulated time, and \uppVar{ScheduleLength} is the desired length of the schedule. This query is run with the trace setting \textit{Best}, meaning it will find the schedule that results in the lowest \textit{cost}, i.e. the highest profit. 
The result of this query is the schedule, and this is what will the \gls{smc} model will build upon.

\begin{equation} \label{eq:cora_q}
E<> t\_time == ScheduleLength
\end{equation}

\subsection*{Processor}
First we will describe the Processor template as it is the base for the entire model. This models the nanosatellite in the sense that it is the one symbolising that the processor is active or idling, as well as consuming power while doing so, as seen in \cref{fig:cora_pro}. \\
The processor template synchronise with the scheduler every time it is ready to execute a payload, the scheduler will then send back a synchronisation if the Processor is allowed to do so. If it is not allowed to execute the payload it will start idling until a change in its environment occurs, indicated by the synchronisation \uppSync{win?}. If the Scheduler indicates it is possible to execute the payload, it may be the case that the environment does not allow it, e.g. if the payload is dependant on a window which the nanosatellite is not currently in, the processor will try to select another payload to run. If the Scheduler approves and all dependencies are fulfilled, the Processor will transition to \uppLoc{Running} where it will remain for the worst case execution time for the selected payload before it transitions to \uppLoc{Wait} where it will remain for the duration of the payloads deadline.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	%Locations
	\node [init] (l0) {$\cup$};
	\node [location] (l1) [right of=l0, xshift=30mm] {$\cup$};
	\node [location] (l2) [right of=l1, xshift=40mm, label={
		[align=left]right:
		\textcolor{name}{ready}
	}] {$\cup$};
	\node [location] (l3) [below of=l1, yshift=-30mm, label={
		[align=right]left:
		\textcolor{name}{Wait}\\
		\textcolor{invariant}{x <= TaskTimes[active][2]}
	}] {};
	\node [location] (l4) [below of=l2, yshift=-30mm, label={
		[align=left]right:
		\textcolor{name}{running}\\
		\textcolor{invariant}{x <= TaskTimes[active][1]}\\
		\textcolor{invariant}{\&\& cost' == runCost}
	}] {};
	\node [location] (l5) [above of=l2, yshift=35mm] {C};
	\node [location] (l6) [above of=l1, yshift=35mm, label={
		[align=left]above:
		\textcolor{name}{Idle}\\
		\textcolor{invariant}{cost' == 5}
	}] {};
	\path[->,black, thick] (l0) edge node [midway, below ][align=center]{\textcolor{update}{mayRun()}} (l1);
	\path[->,black, thick] (l1) edge node [midway, above][align=left]{
		\textcolor{select}{a: int[0,N-1]}\\
		\textcolor{guard}{runnableCount() > 0}\\
		\textcolor{guard}{\&\& runnable[a] == 1}\\
		\textcolor{sync}{ready!}\\
		\textcolor{update}{mayRun(), active = a}} (l2);
	\path[->,black, thick] (l2) edge node [midway, right][align=left]{
		\textcolor{guard}{runnable[active] == 1}\\
		\textcolor{guard}{\&\& !checkBattery()}\\		
		\textcolor{sync}{run?}\\
		\textcolor{update}{updateBattery(), calcCost()}} (l4);
	\path[->,black, thick] (l2) edge[bend right=35] node [midway, left][align=center]{
		\textcolor{sync}{run?}}(l6);
	\path[->,black, thick] (l4) edge node [midway, below][align=center]{
		\textcolor{guard}{x >= taskTimes[active][1]}} (l3);
	\path[->,black, thick] (l3) edge node [midway, left][align=right]{
		\textcolor{guard}{x >= taskTimes[active][2]}\\
		\textcolor{update}{reset(), dequeue(),}\\
		\textcolor{update}{x = 0, mayRun()}} (l1);
	\path[->,black, thick] (l1) edge node [midway, left][align=left]{
		\textcolor{guard}{runnableCount() == 0}} (l6);
	\path[->,black, thick] (l6) edge node [midway, above][align=left]{
		\textcolor{sync}{win?}} (l5);
	\path[->,black, thick] (l5) edge node [midway, right][align=left]{
		\textcolor{select}{a: int[0,N-1]}\\
		\textcolor{sync}{ready!}\\
		\textcolor{update}{mayRun(), active = a}} (l2);
	\path[->,black, thick] (l2) edge[bend left=45] node [midway, below][align=center]{
		\textcolor{guard}{runnable[active] == 0}\\
		\textcolor{guard}{\&\& !checkBattery()}\\
		\textcolor{sync}{run?}} (l1);
	\end{tikzpicture}
	\caption{Task template}
	\label{fig:cora_pro}
\end{figure}



\subsubsection*{Scheduler}
Next we will describe the Scheduler. The scheduler always checks if there are enough remaining energy, when receiving the synchronisation \uppSync{ready?} it will answer back with \uppSync{run!}. If there are no more energy this template will result in a deadlock, and it was therefore not possible to generate a schedule.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
	%Locations
	\node [init] (l0) [label={[align=left]left:
		\textcolor{invariant}{checkBattery()}
	}] {};
	\node [location] (l1) [right of=l0, xshift=40mm, label={
		[align=left]right:
		\textcolor{invariant}{checkBattery()}
	}] {$\cup$};
	\path[->,black, thick] (l0) edge[bend left=30] node [midway, above][align=center]{
		\textcolor{sync}{ready?}} (l1);
	\path[->,black, thick] (l1) edge[bend left=30] node [midway, below][align=center]{
		\textcolor{sync}{run!}} (l0);
	\end{tikzpicture}
	\caption{Scheduler template}
	\label{fig:cora_schedule}
\end{figure}


\subsection*{Insolation}
The insolation template can be seen in \cref{fig:cora_inso}. The model consist of two locations \uppLoc{inSun} and \uppLoc{outSun} to ensure that the nanosatellite can only recharge when it has a clear line of sight to the sun. The recharging is done on the looping edge on \uppLoc{inSun} with the function \uppUpdate{increaseBattery()}. This is done a four times per orbit in order to minimize the state space. When half of the \uppVar{OrbitTime} have passed, modelling the time it takes the nanosatellite to complete one orbit, the model is forced to transition to \uppLoc{outSun}.
A figure of this template can be seen in \cref{cp:cora_models}.

The way this is modelled have a few limitations, as previous mentioned we only recharge four times during insolation, this can in some case cause the scheduler to not make the best trace, but the reduced amount of spaces greatly improves the length of the schedules that can be generated. 
Secondly the model always assume we are starting in \uppLoc{inSun}, resulting in our schedule only being able to generate schedules for the nanosatellite when it matches our starting point.

22094.767
21358.512
23416.569
24534.347
24863.957
25808.023
26497.889
27094.823
26711.223
26577.414
min = 21358.512
max = 27094.823
avg = 24895.752

39980.945
39627.569
46436.725
64678.297
44198.537
45811.89
49083.215
49989.733
50232.486
51243.664
min = 39627.569
max = 64678.297
avg = 48128.306

idle in eclipse not subtracted

\subsection*{TaskWindow}
The last template is the TaskWindow, this template have one instance for each window defined. TaskWindow is used to model part of the nanosatellites environment in the sense that it updates whenever the nanosatellite enters and exits a window during its orbit in which some tasks can be performed. Windows is a important restriction when generating a schedule as some payloads may be pointless to execute in other time periods and would therefore be a waste of energy and time. When a chance to a window occurs it will make the synchronise on the channel \uppChan{win}, with the processor if it is in \uppLoc{Idle} indicating it may now be able to execute some payload. Otherwise it will just transition to the next location updating some global variables indicating if the nanosatellite is within the window or not. 
A figure of this template can be seen in \cref{cp:cora_models}.

